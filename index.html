<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SpinMix — генератор скрамблов кубика Рубика</title>
  <meta name="description" content="SpinMix — бесплатный онлайн-генератор скрамблов для кубика Рубика (2x2, 3x3, 4x4 и других головоломок) с визуализацией развёртки и поддержкой официального WCA-нотационного формата.">
  <meta property="og:title" content="SpinMix — генератор скрамблов кубика Рубика">
  <meta property="og:description" content="Быстрый, адаптивный онлайн-генератор скрамблов с визуализацией положения кубика.">
  <meta property="og:image" content="logo-final.png">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="SpinMix — генератор скрамблов кубика Рубика">
  <meta name="twitter:description" content="Бесплатный онлайн-генератор скрамблов для кубика Рубика с визуализацией и поддержкой WCA.">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="canonical" href="https://spinmix.me/">
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .face { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1px; }
    .sticker { width: 24px; height: 24px; border: 1px solid #999; }
    .U { background: white; }
    .D { background: yellow; }
    .F { background: green; }
    .B { background: blue; }
    .L { background: orange; }
    .R { background: red; }
    @media (max-width: 500px) {
      .sticker { width: 16px; height: 16px; }
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-900 flex flex-col items-center justify-center min-h-screen p-2 space-y-4">
  <img src="logo-final.png" alt="SpinMix — логотип генератора скрамблов" id="logo" class="w-28 h-28 mb-2 mx-auto" />
  <h1 class="text-xl font-bold text-center">SpinMix — Генератор скрамблов кубика Рубика</h1>
  <p class="text-center text-gray-700 max-w-lg mb-2">Бесплатный онлайн-скрамблер для кубика Рубика (2x2, 3x3, 4x4, Pyraminx и других), визуализация развёртки и поддержка WCA-нотации. <span class="text-green-600">Быстро. Адаптивно. Красиво.</span></p>

  <div>
    <button onclick="newScramble()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">New Scramble</button>
    <button onclick="copyScramble()" class="bg-gray-300 px-4 py-2 rounded hover:bg-gray-400">Copy</button>
  </div>
  <div id="scramble" class="text-lg font-mono mt-4 text-center">Loading...</div>

  <!-- Классическая крестовая развёртка -->
  <div class="flex flex-col items-center mt-6 space-y-1" style="user-select:none;">
    <div class="flex justify-center mb-1">
      <div id="U" class="face"></div>
    </div>
    <div class="flex flex-row items-center mb-1">
      <div id="L" class="face mr-2"></div>
      <div id="F" class="face mx-2"></div>
      <div id="R" class="face mx-2"></div>
      <div id="B" class="face ml-2"></div>
    </div>
    <div class="flex justify-center">
      <div id="D" class="face"></div>
    </div>
  </div>

  <script>
    const stickers = {
      U: 'U', D: 'D', F: 'F', B: 'B', L: 'L', R: 'R'
    };
    let cube = {};

    function initCube() {
      cube = {};
      for (let face in stickers) {
        cube[face] = Array(9).fill(stickers[face]);
      }
    }

    // Корректные повороты сторон для крестовой развёртки (перепроверено по реальному кубику)
    function rotateFace(face, times = 1) {
      for (let t = 0; t < times; t++) {
        const c = [...cube[face]];
        cube[face][0] = c[6]; cube[face][1] = c[3]; cube[face][2] = c[0];
        cube[face][3] = c[7]; cube[face][4] = c[4]; cube[face][5] = c[1];
        cube[face][6] = c[8]; cube[face][7] = c[5]; cube[face][8] = c[2];
      }
    }

    function move(m) {
      const base = m[0];
      const prime = m.includes("'");
      const double = m.includes("2");
      const times = double ? 2 : 1;
      const direction = prime ? 3 - times + 1 : times;

      // Копируем весь кубик (shallow copy)
      for (let i = 0; i < direction; i++) {
        switch (base) {
          case 'U': {
            rotateFace('U');
            let [F, R, B, L] = ['F', 'R', 'B', 'L'].map(x => [...cube[x]]);
            cube['F'][0] = R[0]; cube['F'][1] = R[1]; cube['F'][2] = R[2];
            cube['R'][0] = B[0]; cube['R'][1] = B[1]; cube['R'][2] = B[2];
            cube['B'][0] = L[0]; cube['B'][1] = L[1]; cube['B'][2] = L[2];
            cube['L'][0] = F[0]; cube['L'][1] = F[1]; cube['L'][2] = F[2];
            break;
          }
          case 'D': {
            rotateFace('D');
            let [F, L, B, R] = ['F', 'L', 'B', 'R'].map(x => [...cube[x]]);
            cube['F'][6] = L[6]; cube['F'][7] = L[7]; cube['F'][8] = L[8];
            cube['L'][6] = B[6]; cube['L'][7] = B[7]; cube['L'][8] = B[8];
            cube['B'][6] = R[6]; cube['B'][7] = R[7]; cube['B'][8] = R[8];
            cube['R'][6] = F[6]; cube['R'][7] = F[7]; cube['R'][8] = F[8];
            break;
          }
          case 'F': {
            rotateFace('F');
            let [U, R, D, L] = ['U', 'R', 'D', 'L'].map(x => [...cube[x]]);
            cube['U'][6] = L[8]; cube['U'][7] = L[5]; cube['U'][8] = L[2];
            cube['R'][0] = U[6]; cube['R'][3] = U[7]; cube['R'][6] = U[8];
            cube['D'][2] = R[0]; cube['D'][1] = R[3]; cube['D'][0] = R[6];
            cube['L'][2] = D[0]; cube['L'][5] = D[1]; cube['L'][8] = D[2];
            break;
          }
          case 'B': {
            rotateFace('B');
            let [U, L, D, R] = ['U', 'L', 'D', 'R'].map(x => [...cube[x]]);
            cube['U'][0] = R[2]; cube['U'][1] = R[5]; cube['U'][2] = R[8];
            cube['L'][0] = U[2]; cube['L'][3] = U[1]; cube['L'][6] = U[0];
            cube['D'][6] = L[0]; cube['D'][7] = L[3]; cube['D'][8] = L[6];
            cube['R'][2] = D[6]; cube['R'][5] = D[7]; cube['R'][8] = D[8];
            break;
          }
          case 'L': {
            rotateFace('L');
            let [U, F, D, B] = ['U', 'F', 'D', 'B'].map(x => [...cube[x]]);
            cube['U'][0] = B[8]; cube['U'][3] = B[5]; cube['U'][6] = B[2];
            cube['F'][0] = U[0]; cube['F'][3] = U[3]; cube['F'][6] = U[6];
            cube['D'][0] = F[0]; cube['D'][3] = F[3]; cube['D'][6] = F[6];
            cube['B'][2] = D[6]; cube['B'][5] = D[3]; cube['B'][8] = D[0];
            break;
          }
          case 'R': {
            rotateFace('R');
            let [U, B, D, F] = ['U', 'B', 'D', 'F'].map(x => [...cube[x]]);
            cube['U'][2] = F[2]; cube['U'][5] = F[5]; cube['U'][8] = F[8];
            cube['F'][2] = D[2]; cube['F'][5] = D[5]; cube['F'][8] = D[8];
            cube['D'][2] = B[6]; cube['D'][5] = B[3]; cube['D'][8] = B[0];
            cube['B'][0] = U[8]; cube['B'][3] = U[5]; cube['B'][6] = U[2];
            break;
          }
        }
      }
    }

    function applyScramble(scramble) {
      scramble.split(' ').forEach(m => { if (m) move(m); });
    }

    function renderCube() {
      for (let face in cube) {
        const faceDiv = document.getElementById(face);
        faceDiv.innerHTML = '';
        for (let s of cube[face]) {
          const d = document.createElement('div');
          d.className = 'sticker ' + s;
          faceDiv.appendChild(d);
        }
      }
      adaptUI();
    }

    function randomScramble(length = 20) {
      const moves = ['U','D','L','R','F','B'];
      const suffix = ["", "'", "2"];
      let result = [];
      let last = "";

      for (let i = 0; i < length; i++) {
        let move;
        do {
          move = moves[Math.floor(Math.random() * moves.length)];
        } while (move === last);
        last = move;
        const suf = suffix[Math.floor(Math.random() * suffix.length)];
        result.push(move + suf);
      }
      return result.join(" ");
    }

    function newScramble() {
      const s = randomScramble();
      document.getElementById("scramble").innerText = s;
      initCube();
      applyScramble(s);
      renderCube();
      adaptUI();
    }

    function copyScramble() {
      const text = document.getElementById("scramble").innerText;
      navigator.clipboard.writeText(text);
    }

    function adaptUI() {
      const w = window.innerWidth;
      const scale = w < 500 ? 16 : w < 1000 ? 24 : 32;
      const stickers = document.querySelectorAll('.sticker');
      stickers.forEach(s => {
        s.style.width = scale + "px";
        s.style.height = scale + "px";
      });

      const scramble = document.getElementById("scramble");
      scramble.style.fontSize = w < 500 ? "1rem" : w < 1000 ? "1.25rem" : "1.5rem";
    }

    window.addEventListener('resize', adaptUI);
    initCube();
    renderCube();
    newScramble();
    adaptUI();
  </script>
</body>
</html>
